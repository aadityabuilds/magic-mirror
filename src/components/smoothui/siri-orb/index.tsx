"use client"

import type React from "react"
import { useEffect, useRef, useState, useCallback } from "react"

import { cn } from "@/lib/utils"

const SIZE_THRESHOLD_SMALL = 50
const SIZE_THRESHOLD_TINY = 30
const SIZE_THRESHOLD_MEDIUM = 100
const BLUR_MULTIPLIER_SMALL = 0.008
const BLUR_MIN_SMALL = 1
const BLUR_MULTIPLIER_LARGE = 0.015
const BLUR_MIN_LARGE = 4
const CONTRAST_MULTIPLIER_SMALL = 0.004
const CONTRAST_MIN_SMALL = 1.2
const CONTRAST_MULTIPLIER_LARGE = 0.008
const CONTRAST_MIN_LARGE = 1.5
const DOT_SIZE_MULTIPLIER_SMALL = 0.004
const DOT_SIZE_MIN_SMALL = 0.05
const DOT_SIZE_MULTIPLIER_LARGE = 0.008
const DOT_SIZE_MIN_LARGE = 0.1
const SHADOW_MULTIPLIER_SMALL = 0.004
const SHADOW_MIN_SMALL = 0.5
const SHADOW_MULTIPLIER_LARGE = 0.008
const SHADOW_MIN_LARGE = 2
const MASK_RADIUS_TINY = "0%"
const MASK_RADIUS_SMALL = "5%"
const MASK_RADIUS_MEDIUM = "15%"
const MASK_RADIUS_LARGE = "25%"
const CONTRAST_TINY = 1.1
const CONTRAST_MULTIPLIER_FINAL = 1.2
const CONTRAST_MIN_FINAL = 1.3

export type SiriOrbProps = {
  size?: string
  className?: string
  colors?: {
    bg?: string
    c1?: string
    c2?: string
    c3?: string
  }
  animationDuration?: number
  // Audio reactivity props
  audioStream?: MediaStream | null
  isListening?: boolean
  sensitivity?: number // 0-1, controls how sensitive to audio
  minScale?: number // Minimum scale when quiet
  maxScale?: number // Maximum scale at peak volume
  smoothing?: number // 0-1, higher = smoother/slower response
}

const SiriOrb: React.FC<SiriOrbProps> = ({
  size = "192px",
  className,
  colors,
  animationDuration = 20,
  audioStream = null,
  isListening = false,
  sensitivity = 0.5,
  minScale = 1,
  maxScale = 1.3,
  smoothing = 0.96,
}) => {
  const [audioLevel, setAudioLevel] = useState(0)
  const analyserRef = useRef<AnalyserNode | null>(null)
  const animationFrameRef = useRef<number | null>(null)
  const audioContextRef = useRef<AudioContext | null>(null)
  const smoothedLevelRef = useRef(0)
  const targetLevelRef = useRef(0)
  const historyRef = useRef<number[]>([])
  const historySize = 12

  const analyzeAudio = useCallback(() => {
    if (!analyserRef.current) return

    const dataArray = new Uint8Array(analyserRef.current.frequencyBinCount)
    analyserRef.current.getByteFrequencyData(dataArray)

    const average = dataArray.reduce((a, b) => a + b, 0) / dataArray.length
    const normalizedLevel = Math.min(average / 128, 1) * sensitivity

    // Add to history buffer for moving average
    historyRef.current.push(normalizedLevel)
    if (historyRef.current.length > historySize) {
      historyRef.current.shift()
    }
    
    // Calculate moving average
    const movingAverage = historyRef.current.reduce((a, b) => a + b, 0) / historyRef.current.length

    targetLevelRef.current = movingAverage

    // Much slower interpolation for smoother movement
    smoothedLevelRef.current = smoothedLevelRef.current * smoothing + targetLevelRef.current * (1 - smoothing)

    setAudioLevel(smoothedLevelRef.current)

    animationFrameRef.current = requestAnimationFrame(analyzeAudio)
  }, [sensitivity, smoothing])

  useEffect(() => {
    if (!audioStream || !isListening) {
      historyRef.current = []
      const fadeOut = () => {
        smoothedLevelRef.current *= 0.98
        if (smoothedLevelRef.current > 0.001) {
          setAudioLevel(smoothedLevelRef.current)
          animationFrameRef.current = requestAnimationFrame(fadeOut)
        } else {
          smoothedLevelRef.current = 0
          setAudioLevel(0)
        }
      }
      fadeOut()
      return
    }

    audioContextRef.current = new AudioContext()
    analyserRef.current = audioContextRef.current.createAnalyser()
    analyserRef.current.fftSize = 256
    analyserRef.current.smoothingTimeConstant = 0.95

    const source = audioContextRef.current.createMediaStreamSource(audioStream)
    source.connect(analyserRef.current)

    analyzeAudio()

    return () => {
      if (animationFrameRef.current) {
        cancelAnimationFrame(animationFrameRef.current)
      }
      if (audioContextRef.current) {
        audioContextRef.current.close()
      }
    }
  }, [audioStream, isListening, analyzeAudio])

  const defaultColors = {
    bg: "oklch(95% 0.02 264.695)",
    c1: "oklch(75% 0.15 350)", // Pastel pink
    c2: "oklch(80% 0.12 200)", // Pastel blue
    c3: "oklch(78% 0.14 280)", // Pastel purple/lavender
  }

  const finalColors = { ...defaultColors, ...colors }

  const sizeValue = Number.parseInt(size.replace("px", ""), 10)

  const blurAmount =
    sizeValue < SIZE_THRESHOLD_SMALL
      ? Math.max(sizeValue * BLUR_MULTIPLIER_SMALL, BLUR_MIN_SMALL)
      : Math.max(sizeValue * BLUR_MULTIPLIER_LARGE, BLUR_MIN_LARGE)

  const contrastAmount =
    sizeValue < SIZE_THRESHOLD_SMALL
      ? Math.max(sizeValue * CONTRAST_MULTIPLIER_SMALL, CONTRAST_MIN_SMALL)
      : Math.max(sizeValue * CONTRAST_MULTIPLIER_LARGE, CONTRAST_MIN_LARGE)

  const dotSize =
    sizeValue < SIZE_THRESHOLD_SMALL
      ? Math.max(sizeValue * DOT_SIZE_MULTIPLIER_SMALL, DOT_SIZE_MIN_SMALL)
      : Math.max(sizeValue * DOT_SIZE_MULTIPLIER_LARGE, DOT_SIZE_MIN_LARGE)

  const shadowSpread =
    sizeValue < SIZE_THRESHOLD_SMALL
      ? Math.max(sizeValue * SHADOW_MULTIPLIER_SMALL, SHADOW_MIN_SMALL)
      : Math.max(sizeValue * SHADOW_MULTIPLIER_LARGE, SHADOW_MIN_LARGE)

  const getMaskRadius = (value: number) => {
    if (value < SIZE_THRESHOLD_TINY) {
      return MASK_RADIUS_TINY
    }
    if (value < SIZE_THRESHOLD_SMALL) {
      return MASK_RADIUS_SMALL
    }
    if (value < SIZE_THRESHOLD_MEDIUM) {
      return MASK_RADIUS_MEDIUM
    }
    return MASK_RADIUS_LARGE
  }

  const maskRadius = getMaskRadius(sizeValue)

  const getFinalContrast = (value: number) => {
    if (value < SIZE_THRESHOLD_TINY) {
      return CONTRAST_TINY
    }
    if (value < SIZE_THRESHOLD_SMALL) {
      return Math.max(contrastAmount * CONTRAST_MULTIPLIER_FINAL, CONTRAST_MIN_FINAL)
    }
    return contrastAmount
  }

  const finalContrast = getFinalContrast(sizeValue)

  const scale = minScale + audioLevel * (maxScale - minScale)
  const dynamicBlur = blurAmount * (1 + audioLevel * 0.3)
  const dynamicAnimationSpeed = animationDuration / (1 + audioLevel * 0.3)

  return (
    <div
      className={cn("siri-orb", className, isListening ? "speaking" : "")}
      style={
        {
          width: size,
          height: size,
          "--bg": finalColors.bg,
          "--c1": finalColors.c1,
          "--c2": finalColors.c2,
          "--c3": finalColors.c3,
          "--animation-duration": `${dynamicAnimationSpeed}s`,
          "--blur-amount": `${dynamicBlur}px`,
          "--contrast-amount": finalContrast,
          "--dot-size": `${dotSize}px`,
          "--shadow-spread": `${shadowSpread}px`,
          "--mask-radius": maskRadius,
          "--scale": scale,
          "--audio-level": audioLevel,
          transform: `scale(${scale})`,
          transition: "transform 0.5s cubic-bezier(0.25, 0.1, 0.25, 1)",
        } as React.CSSProperties
      }
    >
      <style>{`
        @property --angle {
          syntax: "<angle>";
          inherits: false;
          initial-value: 0deg;
        }

        .siri-orb {
          display: grid;
          grid-template-areas: "stack";
          overflow: hidden;
          border-radius: 50%;
          position: relative;
          will-change: transform;
        }

        .siri-orb::before,
        .siri-orb::after {
          content: "";
          display: block;
          grid-area: stack;
          width: 100%;
          height: 100%;
          border-radius: 50%;
        }

        .siri-orb::before {
          background:
            conic-gradient(
              from calc(var(--angle) * 2) at 25% 70%,
              var(--c3),
              transparent 20% 80%,
              var(--c3)
            ),
            conic-gradient(
              from calc(var(--angle) * 2) at 45% 75%,
              var(--c2),
              transparent 30% 60%,
              var(--c2)
            ),
            conic-gradient(
              from calc(var(--angle) * -3) at 80% 20%,
              var(--c1),
              transparent 40% 60%,
              var(--c1)
            ),
            conic-gradient(
              from calc(var(--angle) * 2) at 15% 5%,
              var(--c2),
              transparent 10% 90%,
              var(--c2)
            ),
            conic-gradient(
              from calc(var(--angle) * 1) at 20% 80%,
              var(--c1),
              transparent 10% 90%,
              var(--c1)
            ),
            conic-gradient(
              from calc(var(--angle) * -2) at 85% 10%,
              var(--c3),
              transparent 20% 80%,
              var(--c3)
            );
          box-shadow: inset var(--bg) 0 0 var(--shadow-spread)
            calc(var(--shadow-spread) * 0.2);
          filter: blur(var(--blur-amount)) contrast(var(--contrast-amount));
          animation: rotate var(--animation-duration) linear infinite;
        }

        .siri-orb::after {
          background-image: radial-gradient(
            circle at center,
            var(--bg) var(--dot-size),
            transparent var(--dot-size)
          );
          background-size: calc(var(--dot-size) * 2) calc(var(--dot-size) * 2);
          backdrop-filter: blur(calc(var(--blur-amount) * 2))
            contrast(calc(var(--contrast-amount) * 2));
          mix-blend-mode: overlay;
        }

        .siri-orb[style*="--mask-radius: 0%"]::after {
          mask-image: none;
        }

        .siri-orb:not([style*="--mask-radius: 0%"])::after {
          mask-image: radial-gradient(
            black var(--mask-radius),
            transparent 75%
          );
        }

        @keyframes rotate {
          to {
            --angle: 360deg;
          }
        }

        @media (prefers-reduced-motion: reduce) {
          .siri-orb::before {
            animation: none;
          }
        }
      `}</style>

      <style>{`
        .siri-orb.speaking {
          animation: speaking-pulse 1s ease-in-out infinite;
        }

        @keyframes speaking-pulse {
          0%, 100% {
            transform: scale(var(--scale)) translateZ(0);
          }
          50% {
            transform: scale(calc(var(--scale) * 1.05)) translateZ(0);
          }
        }
      `}</style>
    </div>
  )
}

export default SiriOrb
